"""
    MicroProblem(...)

Simulates soil and microclimate dynamics over multiple days.

# Overview generated by ChatGPT
- Interpolates daily min/max weather (temperature, wind, humidity, cloud)
  to hourly steps.
- Solves the soil energy balance using an ODE each hour.
- Optionally simulates soil moisture (`runmoist=true`).
- Returns detailed outputs for soil, air, radiation, and water balance.

# Hourly Weather Interpolation
- Daily min/max values are interpolated to 24-hour vectors 
  (e.g. `TAIRs`).
- Matches the Fortran/R approach where an extra hour smooths 
  interpolation.

# Soil Layer Setup
- `numnodes_a`: number of nodes for temperature output.
- `numnodes_b`: expanded nodes for moisture (`numnodes_a * 2 - 2`).
- Initializes temperature (`θ_soil0_a`) and moisture (`θ_soil0_b`).
- Tracks water phase transitions in `Σphase`.

# Solar Radiation
- `solar_radiation` computes clear-sky radiation.
- Zenith angles capped at 90°.
- Clouds adjust radiation with `cloud_adjust_radiation`.

# Time Loop
- Outer loop: days.
- Inner loop: hours.
- Supports spin-up or multi-iteration (`iterate_day`).
- Each hour:
  * `soil_energy_balance!` updates temperature.
  * `get_soil_water_balance` updates moisture (optional).
  * Soil properties (`bulk_thermal_conductivity`, `bulk_heat_capacity`, `bulk_density`) updated.
  * Sky temperature computed with `longwave_radiation`.

# Profiles
- After all days, computes air, wind, humidity profiles
  via `atmospheric_surface_profile`.
- Results are "flipped" into vectors with `flip2vectors`.

# Return Values
Returns a named tuple containing:
- Air/wind/RH profiles
- Cloud cover and solar radiation
- Soil temperature, moisture, water potential, RH
- Soil thermal properties and bulk density
- Surface water pools
- `solar_radiation_out` and `profile_out` for detailed internals

# Notes
- **Units**: Uses `Unitful.jl`. Ensure all functions
  preserve units.
- **Memory**: Large arrays (`T_soils`, `θ_soils`):verbose set showmode?
  may be heavy for long runs.
- **Interpolation**: Extra 25th hour is correct but
  needs careful indexing.
- **Phase tranitions**: Applied hourly; check
  `Σphase` across multi-day runs.
- **Moisture logic**: Updates depend on
  `i == 1` or `i < length(hours)`; confirm
  matches Fortran/R logic.
"""
@kwdef struct MicroProblem
    # locations, times, depths and heights
    # These are fine to keep as defaults, theyre generic
    days = [15, 46, 74, 105, 135, 166, 196, 227, 258, 288, 319, 349] # days of year to simulate - TODO leap years - why not use real dates?
    hours = collect(0.0:1:23.0) # hour of day for solar_radiation
    depths = DEFAULT_DEPTHS # soil nodes - keep spacing close near the surface
    heights = [0.01, 2]u"m" # air nodes for temperature, wind speed and humidity profile, last height is reference height for weather data
    # TODO: this should be mandatory with no default??
    latitude
    # Objects defined above
    solar_model = SolarProblem()
    solar_terrain
    micro_terrain
    soil_moisture_model
    soil_thermal_model
    environment_minmax
    environment_hourly = nothing
    environment_daily
    # intial conditions TODO: where to put these?
    initial_soil_temperature = fill(u"K"(7.741667u"°C"), length(depths))
    initial_soil_moisture = fill(0.42 * 0.25, length(depths))
    iterate_day = 3 # number of iterations per day
    # TODO: make these types so their code blocks can be removed by the compiler
    daily = false # doing consecutive days? Only used in hourly interpolator from min/max data
    runmoist = false # run soil moisture algorithm?
    hourly_rainfall = false # use hourly rainfall?
    spinup = false # spin-up the first day by iterate_day iterations?
end

function example_microclimate_problem(;
    latitude = 43.07305u"°",
    micro_terrain=default_terrain(),
    soil_moisture_model=example_soil_moisture_model(),
    soil_thermal_model=example_soil_thermal_parameters(),
    environment_minmax=example_monthly_weather(),
    environment_daily=example_daily_environment(),
    kw...
)
    MicroProblem(; 
         latitude, micro_terrain, solar_terrain, soil_moisture_model, soil_thermal_model, environment_minmax, environment_daily, kw...
    )
end

# TODO some of these can be actual defaults ?
function example_micro_terrain(;
    elevation = 226.0u"m", # elevation (m)
    roughness_height = 0.004u"m", # heat transfer roughness height
    karman_constant = 0.4, # Kármán constant
    dyer_constant = 16.0, # coefficient from Dyer and Hicks for Φ_m (momentum), γ
)
    MicroTerrain(; elevation, roughness_height, karman_constant, dyer_constant)
end

function example_monthly_weather(;
    reference_temperature_min = [-14.3, -12.1, -5.1, 1.2, 6.9, 12.3, 15.2, 13.6, 8.9, 3, -3.2, -10.6]u"°C",
    reference_temperature_max = [-3.2, 0.1, 6.8, 14.6, 21.3, 26.4, 29, 27.7, 23.3, 16.6, 7.8, -0.4]u"°C",
    reference_wind_min = [4.9, 4.8, 5.2, 5.3, 4.6, 4.3, 3.8, 3.7, 4, 4.6, 4.9, 4.8] * 0.1u"m/s",
    reference_wind_max = [4.9, 4.8, 5.2, 5.3, 4.6, 4.3, 3.8, 3.7, 4, 4.6, 4.9, 4.8]u"m/s",
    reference_humidity_min = [50.2, 48.4, 48.7, 40.8, 40, 42.1, 45.5, 47.3, 47.6, 45, 51.3, 52.8] ./ 100.0,
    reference_humidity_max = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100] ./ 100.0,
    cloud_min = [50.3, 47, 48.2, 47.5, 40.9, 35.7, 34.1, 36.6, 42.6, 48.4, 61.1, 60.1] ./ 100.0,
    cloud_max = [50.3, 47, 48.2, 47.5, 40.9, 35.7, 34.1, 36.6, 42.6, 48.4, 61.1, 60.1] ./ 100.0,
    minima_times = (temp=0, wind=0, humidity=1, cloud=1), # time of minima for air temp, wind, humidity and cloud cover (h), air & wind mins relative to sunrise, humidity and cloud cover mins relative to solar noon
    maxima_times = (temp=1, wind=1, humidiy=0, cloud=0), # time of maxima for air temp, wind, humidity and cloud cover (h), air temp & wind maxs relative to solar noon, humidity and cloud cover maxs relative to sunrise
)
    MonthlyMinMaxWeather(reference_temperature_min, reference_temperature_max, reference_wind_min, reference_wind_max, reference_humidity_min, reference_humidity_max, cloud_min, cloud_max, minima_times, maxima_times)
end

function example_soil_thermal_parameters(;
    deVries_shape_factor = 0.1, # de Vries shape factor, 0.33 for organic soils, 0.1 for mineral
    soil_mineral_conductivity = 1.25u"W/m/K", # soil minerals thermal conductivity
    soil_mineral_density = 2.560u"Mg/m^3", # soil minerals density
    soil_mineral_heat_capacity = 870.0u"J/kg/K", # soil minerals specific heat
    soil_bulk_density = 2.56u"Mg/m^3", # dry soil bulk density
    # TODO why is this calculated elsewhere but also specified here
    soil_saturation_moisture = 0.26u"m^3/m^3", # volumetric water content at saturation (0.1 bar matric potential)
    recirculation_power = 4.0, # power for recirculation function
    return_flow_threshold = 0.162, # return-flow cutoff soil moisture, m^3/m^3
)
    CampbelldeVriesSoilThermal(
        deVries_shape_factor, soil_mineral_conductivity, soil_mineral_density, soil_mineral_heat_capacity,
        soil_bulk_density, soil_saturation_moisture, recirculation_power, return_flow_threshold
    )
end

# TODO move real defaults to the struct keywords
function example_soil_moisture_model(depths=DEFAULT_DEPTHS; 
    bulk_density,
    mineral_density,
    # soil moisture model soil parameters
    air_entry_water_potential = fill(0.7, length(depths) * 2 - 2)u"J/kg", #air entry potential
    saturated_hydraulic_conductivity = fill(0.0058, length(depths) * 2 - 2)u"kg*s/m^3", #saturated conductivity
    Campbells_b_parameter = fill(1.7, length(depths) * 2 - 2), #soil 'b' parameter
    soil_bulk_density2 = fill(bulk_density, length(depths) * 2 - 2)u"Mg/m^3", # soil bulk density
    # TODO what is this why are they different
    soil_mineral_density2 = fill(mineral_density, length(depths) * 2 - 2)u"Mg/m^3", # soil mineral density
    # soil moisture plant parameters
    root_density = [0, 0, 8.2, 8.0, 7.8, 7.4, 7.1, 6.4, 5.8, 4.8, 4.0, 1.8, 0.9, 0.6, 0.8, 0.4, 0.4, 0, 0] * 1e4u"m/m^3", # root density at each node (from Campell 1985 Soil Physics with Basic, p. 131)
    root_resistance = 2.5e+10u"m^3/kg/s", # resistance per unit length of root
    stomatal_closure_potential = -1500.0u"J/kg", # critical leaf water potential for stomatal closure
    leaf_resistance = 2.0e6u"m^4/kg/s", # resistance per unit length of leaf
    stomatal_stability_parameter = 10.0, # stability parameter, -
    root_radius = 0.001u"m", # root radius, m
    # soil moisture simulation controls
    moist_error = 1e-6u"kg/m^2/s", # maximum overall mass balance error allowed
    moist_count = 500, # maximum iterations of soil moisture algorithm
    moist_step = 360.0u"s", # time step over which to simulate soil moisture (< =  1 hour)
    maxpool = 1.0e4u"kg/m^2", # maximum depth of pooling water
)
    SoilMoistureModel(
        air_entry_water_potential, saturated_hydraulic_conductivity, Campbells_b_parameter, soil_bulk_density2,
        soil_mineral_density2, root_density, root_resistance, stomatal_closure_potential, leaf_resistance, stomatal_stability_parameter,
        root_radius, moist_error, moist_count, moist_step, maxpool
    )
end
function example_daily_environmental(;
    shade = fill(0.0, length(days)), # fractional shade cast by vegetation
    soil_wetness = fill(0.0, length(days)), # fractional surface wetness
    surface_emissivity = fill(0.96, length(days)), # - surface emissivity
    cloud_emissivity = fill(0.96, length(days)), # - cloud emissivity
    rainfall = ([28, 28.2, 54.6, 79.7, 81.3, 100.1, 101.3, 102.5, 89.7, 62.4, 54.9, 41.2])u"kg/m^2",
    deep_soil_temperature = fill(7.741666u"°C", length(days)),
    leaf_area_index = fill(0.1, length(days)),
)
    EnvironmentTimeseries(; albedo, shade, soil_wetness, surface_emissivity, cloud_emissivity, rainfall, deep_soil_temperature, leaf_area_index)
end

function solve(mp::MicroProblem)
    (; environment_minmax, environment_daily, environment_hourly, days, hours, depths, heights) = mp
    ndays = length(days)
    nhours = length(hours)
    nsteps = ndays * nhours
    numnodes_a = length(depths) # number of soil nodes for temperature calcs and final output

    # Calculate clear sky solar
    solar_radiation_out = solve_solar(mp)
    # Define the output
    output = MicroResult(nsteps, numnodes_a, solar_radiation_out)
    # Interpolate minmax weather
    interpolate_minmax!(output, environment_minmax, environment_daily, environment_hourly, solar_radiation_out)
    # Adjust solar_radiation given cloud cover to get diffuse fraction
    (; global_solar, diffuse_fraction) = adjust_for_cloud_cover(output, solar_radiation_out, days, hours)
    output.diffuse_fraction .= diffuse_fraction
    # Check if cloud-adjusted solar was originally provided
    if !isnothing(environment_hourly)
        if !isnothing(environment_hourly.global_radiation)
            # Output the original input values
            output.global_solar .= environment_hourly.global_radiation
        else
            # Output the cloud-adjusted clear-sky values
            output.global_solar .= global_solar
        end
    else
        # Output the cloud-adjusted clear-sky values
        output.global_solar .= global_solar
    end
    # Solve soil temperature and moisture
    solve_soil!(output, mp, solar_radiation_out; days, hours, depths, heights)
    # Solve air temperatures, windspeed and humidity
    solve_air!(output, solar_radiation_out, mp)

    return output
end

function solve_solar(mp::MicroProblem)
    (; solar_model, days, hours, latitude, solar_terrain) = mp
    # compute clear sky solar radiation
    solar_radiation_out = solar_radiation(solar_model; days, hours, latitude, solar_terrain)
    # limit max zenith angles to 90°
    solar_radiation_out.zenith_angle[solar_radiation_out.zenith_angle .> 90u"°"] .= 90u"°"
    solar_radiation_out.zenith_slope_angle[solar_radiation_out.zenith_slope_angle .> 90u"°"] .= 90u"°"

    return solar_radiation_out
end

function interpolate_minmax!(output, environment_minmax, environment_daily, environment_hourly, solar_radiation_out)
    # interpolate daily min/max forcing variables to hourly
    reference_temperature, reference_wind_speed, reference_humidity, cloud_cover = hourly_vars(environment_minmax, solar_radiation_out)
    # TODO just use loops for these this allocates
    reference_humidity[reference_humidity .> 1.0] .= 1.0
    cloud_cover[cloud_cover .> 1.0] .= 1.0

    output.cloud_cover .= cloud_cover
    output.reference_temperature .= reference_temperature
    output.pressure .= environment_hourly.pressure
    output.reference_wind_speed .= reference_wind_speed
    output.reference_humidity .= reference_humidity

    return 
end
function interpolate_minmax!(output, environment_minmax::Nothing, environment_daily, environment_hourly, solar_radiation_out)
    output.cloud_cover .= environment_hourly.cloud_cover
    output.reference_temperature .= environment_hourly.reference_temperature
    output.pressure .= environment_hourly.pressure
    output.reference_wind_speed .= environment_hourly.reference_wind_speed
    output.reference_humidity .= environment_hourly.reference_humidity

    return 
end

function adjust_for_cloud_cover(output, solar_radiation_out, days, hours)
    # adjust for cloud using Angstrom formula (formula 5.33 on P. 177 of "Climate Data and Resources" by Edward Linacre 1992
    day_of_year = repeat(days, inner=length(hours))
    zenith_angle = solar_radiation_out.zenith_angle
    direct_total = solar_radiation_out.direct_total
    diffuse_total = solar_radiation_out.diffuse_total
    cloud = output.cloud_cover
    return (; global_solar, diffuse_fraction) = cloud_adjust_radiation(output, cloud, diffuse_total, direct_total, zenith_angle, day_of_year)
end

# Solves soil temperature and moisture
function solve_soil!(output::MicroResult, mp::MicroProblem, solar_radiation_out; 
    days, hours, depths, heights
)
    (; solar_terrain, micro_terrain, soil_thermal_model, soil_moisture_model, environment_minmax, environment_daily, daily, initial_soil_temperature, initial_soil_moisture, runmoist, hourly_rainfall) = mp
    (; moist_step, Campbells_b_parameter, soil_bulk_density2, soil_mineral_density2, air_entry_water_potential) = soil_moisture_model

    ndays = length(days)
    nhours = length(hours)
    numnodes_a = length(depths) # number of soil nodes for temperature calcs and final output
    numnodes_b = numnodes_a * 2 - 2 # number of soil nodes for soil moisture calcs

    # initial conditions
    if !daily && isnothing(initial_soil_temperature)
        #t = mean(u"K", view(output.reference_temperature, 1:nhours))
        # TODO below we add the first value to the other 24 so that it mimics the Fortran 25h day but 
        # ultimately we should remove that extra value
        t = mean(u"K", [view(output.reference_temperature, 1:nhours); output.reference_temperature[1]])
        T0 = SVector(ntuple(_ -> t, numnodes_a))
    else
        # TODO move all input-related error messages to MicroProblem constructor
        if numnodes_a != length(initial_soil_temperature)
            error("Initial soil temperature must match length of 'depths'")
        end
        T0 = SVector(ntuple(i -> initial_soil_temperature[i], numnodes_a))
    end  

    # Soil properties
    # set up a profile of soil properties with depth for each day to be run
    nodes_day = zeros(numnodes_a, ndays) # array of all possible soil nodes
    nodes_day[1, 1:ndays] .= numnodes_a # deepest node for first substrate type
    # These could also be vectors if we let users specify them
    ∑phase = zeros(typeof(1.0u"J"), numnodes_a) # zero phase transition for liquid water in soil

    (; θ_soil0_a, θ_soil0_b) = initialise_soil_moisture(initial_soil_moisture, numnodes_b)

    nodes = nodes_day[:, 1]
    M = 18 # soil_water_balance default
    buffers = (;
        profile = allocate_profile(heights),
        soil_energy_balance = allocate_soil_energy_balance(numnodes_b),  # only once
        soil_properties = allocate_soil_properties(nodes, soil_thermal_model),
        phase_transition = allocate_phase_transition(length(depths)),
        soil_water_balance = allocate_soil_water_balance(numnodes_b),  # only once
    )
    update_soil_properties!(output, buffers.soil_properties, soil_thermal_model;
        soil_temperature=T0, soil_moisture=θ_soil0_a, P_atmos=101325.0u"Pa", step=1
    )
    sub = vcat(findall(isodd, 1:numnodes_b), numnodes_b)

    soil_saturation_moisture = 1.0 .- soil_bulk_density2 ./ soil_mineral_density2
    output.soil_water_potential[1, :] .= air_entry_water_potential[sub] .* (soil_saturation_moisture[sub] ./ θ_soil0_a) .^ Campbells_b_parameter[sub]
    output.soil_temperature[1, :] .= T0
    output.soil_moisture[1, :] = θ_soil0_a

    if runmoist
        MW = 0.01801528u"kg/mol" # molar mass of water, kg/mol # TODO use UnitfulMoles
        output.soil_humidity[1, :] = clamp.(exp.(MW .* output.soil_water_potential[1, :] ./ (R .* T0)), 0, 1)
    end

    environment_day = get_day(environment_daily, 1)
    environment_instant = get_instant(environment_day, mp.environment_hourly, output, θ_soil0_a, 1)
    longwave_out = longwave_radiation(; micro_terrain, surface_temperature=T0[1], environment_instant)

    # simulate all days
    pool = 0.0u"kg/m^2" # initialise depth of pooling water TODO make this an init option
    niter_moist = ustrip(u"s^-1", 3600 / moist_step) # TODO use a solver for soil moisture calc
    infil_out = nothing
    if !runmoist
        soil_wetness = environment_instant.soil_wetness
    else
        soil_wetness = 0.0
    end
    for j in 1:ndays
        iday = j
        nodes .= nodes_day[:, iday]
        environment_day = get_day(environment_daily, iday)
        forcing = forcing_day(solar_radiation_out, output, iday)
        niter = (mp.spinup && j == 1 || !daily) ? mp.iterate_day : 1
        if !daily
            ∑phase .= 0.0u"J"
            sub2 = (iday*nhours-nhours+1):(iday*nhours) # for getting mean monthly over the 25 hrs as in fortran version
            if isnothing(initial_soil_temperature)
                t = mean(u"K", [output.reference_temperature[sub2]; output.reference_temperature[sub2][1]])
                T0 = SVector(ntuple(_ -> t, numnodes_a))
            else
                T0 = copy(initial_soil_temperature)
            end
            θ_soil0_a = initial_soil_moisture # initial soil moisture
        end
        T0 = setindex(T0, environment_instant.deep_soil_temperature, numnodes_a) # set deepest node to boundary condition
        for iter = 1:niter
            ∑phase .= 0.0u"J" # TODO decied whether this should happen and fix in Fortran
            for i in 1:length(hours) # loop through hours of day
                step = (j - 1) * length(hours) + i
                environment_instant = get_instant(environment_day, mp.environment_hourly, output, θ_soil0_a, step)
                if i == 1 # make first hour of day equal last hour of previous iteration
                    if niter > 1
                        ∑phase .= 0.0u"J" # TODO decide whether this should happen and fix in Fortran
                        inputs = SoilEnergyInputs(; forcing, buffers, soil_thermal_model, depths, heights, solar_terrain, micro_terrain, runmoist, nodes, environment_instant, soil_wetness)
                        soiltemps = get_soil_temp_timeline(T0, inputs, i + 1)
                        T0 = soiltemps[2]
                        if iter == niter # TODO this should happen every time but at present it doesn't in Fortran version
                            ∑phase, qphase, T0 = phase_transition!(buffers.phase_transition;
                                Ts = soiltemps[2], T_past = soiltemps[1], ∑phase, θ = θ_soil0_a, depths
                            )
                        end
                    end
                else
                    inputs = SoilEnergyInputs(; forcing, buffers, soil_thermal_model, depths, heights, solar_terrain, micro_terrain, runmoist, nodes, environment_instant, soil_wetness)
                    soiltemps = get_soil_temp_timeline(T0, inputs, i)
                    T0 = soiltemps[2]
                    if iter == niter # TODO this should happen every time but at present it doesn't in Fortran version
                        ∑phase, qphase, T0 = phase_transition!(buffers.phase_transition;
                            Ts = soiltemps[2], T_past = soiltemps[1], ∑phase, θ = θ_soil0_a, depths
                        )
                    end
                end
                rain = hourly_rainfall ? mp.environment_hourly.rainfall[step] : environment_instant.rainfall
                pool = clamp(pool + rain, 0.0u"kg/m^2", soil_moisture_model.maxpool)
                if runmoist
                    infil_out, soil_wetness, pool, θ_soil0_b = get_soil_water_balance!(buffers, soil_moisture_model;
                        depths, micro_terrain, environment_instant, T0, niter_moist, pool, soil_wetness,
                        soil_moisture = θ_soil0_b
                    )
                    update_soil_water!(output, infil_out, sub, step)
                    θ_soil0_a = θ_soil0_b[sub]
                end
                # Write to output
                if iter == niter
                    output.surface_water[step] = pool
                    output.soil_temperature[step, :] .= T0
                    longwave_out = longwave_radiation(; micro_terrain, environment_instant, surface_temperature=T0[1])
                    output.sky_temperature[step] = longwave_out.Tsky
                                    environment_instant = get_instant(environment_day, mp.environment_hourly, output, θ_soil0_a, step)

                                    update_soil_properties!(output, buffers.soil_properties, soil_thermal_model;
                        soil_temperature=T0, soil_moisture=θ_soil0_a, P_atmos=environment_instant.P_atmos, step
                    )
                end
            end
        end
    end
    return output
end

# compute air temperature, wind speed and relative humidity profiles
function solve_air!(output::MicroResult, solar_radiation_out, mp::MicroProblem)
    (; heights, micro_terrain) = mp
    profile_buffers = allocate_profile(heights)
    for i in 1:length(output.profile)
        # TODO standardise these names
        surface_temperature=u"°C"(output.soil_temperature[i][1])
        environment_instant = (;
            P_atmos=output.pressure[i],
            reference_temperature=output.reference_temperature[i],
            reference_wind_speed=output.reference_wind_speed[i],
            reference_humidity=output.reference_humidity[i],
            zenith_angle=solar_radiation_out.zenith_angle[i],
        )
        # compute scalar profiles
        output.profile[i] = atmospheric_surface_profile!(profile_buffers; micro_terrain, environment_instant, surface_temperature)
    end
end

function get_soil_temp_timeline(T0, input, i)
    tspan = ((0.0 + (i - 2) * 60)u"minute", (60.0 + (i - 2) * 60)u"minute")  # 1 hour
    prob = ODEProblem{false}(soil_energy_balance, T0, tspan, input)
    sol = SciMLBase.solve(prob, Tsit5(); saveat=60.0u"minute", reltol=1e-6u"K", abstol=1e-8u"K")
    return sol.u
end

function update_soil_properties!(output, soil_properties_buffers, soil_thermal_model; step, kw...)
    (; λ_b, cp_b, ρ_b) = soil_properties!(soil_properties_buffers, soil_thermal_model; kw...)

    output.soil_thermal_conductivity[step, :] .= λ_b
    output.soil_heat_capacity[step, :] .= cp_b
    output.soil_bulk_density[step, :] .= ρ_b

    return output
end

function update_soil_water!(output, infil_out, sub, step)
    output.soil_moisture[step, :] .= infil_out.θ_soil[sub]
    output.soil_water_potential[step, :] .= infil_out.ψ_soil[sub]
    output.soil_humidity[step, :] .= infil_out.rh_soil[sub]

    return output
end

# TODO eventually make environment a type,
# and this can just be `getindex` on that type.
function forcing_day(solar_radiation_out, output, iday::Int)
    (; pressure, reference_temperature, reference_wind_speed, reference_humidity, cloud_cover) = output
    # TODO: rename this
    global_solar = output.global_solar
    (; zenith_angle, zenith_slope_angle) = solar_radiation_out

    nhours = 24
    sub1 = (iday*nhours-nhours+1):(iday*nhours)
    tspan = 0.0:60:(60*(nhours-1))

    # get today's weather
    interpolate_solar = scale(interpolate(global_solar[sub1], BSpline(Linear())), tspan)
    interpolate_zenith = scale(interpolate(zenith_angle[sub1], BSpline(Linear())), tspan)
    interpolate_slope_zenith = scale(interpolate(zenith_slope_angle[sub1], BSpline(Linear())), tspan)
    interpolate_temperature = scale(interpolate(u"K".(reference_temperature[sub1]), BSpline(Linear())), tspan)
    interpolate_wind = scale(interpolate(reference_wind_speed[sub1], BSpline(Linear())), tspan)
    interpolate_humidity = scale(interpolate(reference_humidity[sub1], BSpline(Linear())), tspan)
    interpolate_cloud = scale(interpolate(cloud_cover[sub1], BSpline(Linear())), tspan)
    interpolate_pressure = scale(interpolate(pressure[sub1], BSpline(Linear())), tspan)

    return MicroForcing(; interpolate_solar, interpolate_zenith, interpolate_slope_zenith, interpolate_temperature, interpolate_wind, interpolate_humidity, interpolate_cloud, interpolate_pressure)
end

function initialise_soil_moisture(initial_soil_moisture, numnodes_b)
    θ_soil0_a = copy(initial_soil_moisture) # initial soil moisture
    θ_soil0_b = similar(θ_soil0_a, numnodes_b)  # preallocate vector of length numnodes_b
    jj = 1
    for ii in 1:numnodes_b
        if isodd(ii)
            θ_soil0_b[ii] = θ_soil0_a[jj]
            jj += 1
        else
            θ_soil0_b[ii] = θ_soil0_b[ii-1]
        end
    end

    return (; θ_soil0_a, θ_soil0_b)
end

# TODO these functions are a bit silly
function get_day(environment_daily, iday)
    # TODO: standardise all these names
    environment_day = (;
        leaf_area_index = environment_daily.leaf_area_index[iday],
        shade = environment_daily.shade[iday], # daily shade (fractional)
        surface_emissivity = environment_daily.surface_emissivity[iday],
        cloud_emissivity = environment_daily.cloud_emissivity[iday], # - cloud emissivity
        soil_wetness = environment_daily.soil_wetness[iday], # set up vector of soil wetness for each day
        deep_soil_temperature = u"K"(environment_daily.deep_soil_temperature[iday]), # daily deep soil temperature (°C)
        rainfall = environment_daily.rainfall[iday],
    )
end
function get_instant(environment_day, environment_hourly, output, θ_soil0_a, i)
    return (;
        environment_day...,
        # TODO getting data from output means it being correct depends on
        # order of operations in the solve. We need an itermediate object instead
        P_atmos = output.pressure[i],
        reference_temperature = output.reference_temperature[i],
        reference_wind_speed = output.reference_wind_speed[i],
        reference_humidity = output.reference_humidity[i],
        zenith_angle = output.solar_radiation.zenith_angle[i],
        cloud_cover = output.cloud_cover[i],
        global_solar = output.global_solar[i],
        soil_moisture=θ_soil0_a,
    )
end

# This handles getting values from a Number or array of numbers, or objects of these
maybegetindex(obj::CampbelldeVriesSoilThermal, i::Int) = CampbelldeVriesSoilThermal(; maybegetindex(ConstructionBase.getproperties(obj), i)...)
maybegetindex(props::NamedTuple, i::Int) = map(p -> maybegetindex(p, i), props)
maybegetindex(val::Number, i::Int) = val
maybegetindex(vals::AbstractArray, i::Int) = vals[i]
