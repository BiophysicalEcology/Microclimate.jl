"""
    MicroProblem(...)

Simulates soil and microclimate dynamics over multiple days.

# Overview generated by ChatGPT
- Interpolates daily min/max weather (temperature, wind, humidity, cloud)
  to hourly steps.
- Solves the soil energy balance using an ODE each hour.
- Optionally simulates soil moisture (`runmoist=true`).
- Returns detailed outputs for soil, air, radiation, and water balance.

# Hourly Weather Interpolation
- Daily min/max values are interpolated to 24-hour vectors 
  (e.g. `TAIRs`).
- Matches the Fortran/R approach where an extra hour smooths 
  interpolation.

# Soil Layer Setup
- `numnodes_a`: number of nodes for temperature output.
- `numnodes_b`: expanded nodes for moisture (`numnodes_a * 2 - 2`).
- Initializes temperature (`θ_soil0_a`) and moisture (`θ_soil0_b`).
- Tracks water phase transitions in `Σphase`.

# Solar Radiation
- `solrad` computes clear-sky radiation.
- Zenith angles capped at 90°.
- Clouds adjust radiation with `cloud_adjust_radiation`.

# Time Loop
- Outer loop: days.
- Inner loop: hours.
- Supports spin-up or multi-iteration (`iterate_day`).
- Each hour:
  * `soil_energy_balance!` updates temperature.
  * `get_soil_water_balance` updates moisture (optional).
  * Soil properties (`λ_bulk`, `c_p_bulk`, `ρ_bulk`) updated.
  * Sky temperature computed with `longwave_radiation`.

# Profiles
- After all days, computes air, wind, humidity profiles
  via `atmospheric_surface_profile`.
- Results are "flipped" into vectors with `flip2vectors`.

# Return Values
Returns a named tuple containing:
- Air/wind/RH profiles
- Cloud cover and solar radiation
- Soil temperature, moisture, water potential, RH
- Soil thermal properties and bulk density
- Surface water pools
- `solrad_out` and `profile_out` for detailed internals

# Notes
- **Units**: Uses `Unitful.jl`. Ensure all functions
  preserve units.
- **Memory**: Large arrays (`T_soils`, `θ_soils`):verbose set showmode?
  may be heavy for long runs.
- **Interpolation**: Extra 25th hour is correct but
  needs careful indexing.
- **Phase tranitions**: Applied hourly; check
  `Σphase` across multi-day runs.
- **Moisture logic**: Updates depend on
  `i == 1` or `i < length(hours)`; confirm
  matches Fortran/R logic.
"""
@kwdef struct MicroProblem
    # locations, times, depths and heights
    # These are fine to keep as defaults, theyre generic
    days = [15, 46, 74, 105, 135, 166, 196, 227, 258, 288, 319, 349] # days of year to simulate - TODO leap years - why not use real dates?
    hours = collect(0.0:1:23.0) # hour of day for solrad
    depths = DEFAULT_DEPTHS # soil nodes - keep spacing close near the surface
    heights = [0.01, 2]u"m" # air nodes for temperature, wind speed and humidity profile, last height is reference height for weather data
    # TODO: this should be mandatory with no default??
    latitude
    # Objects defined above
    solar_model = SolarRadiation()
    terrain
    soil_moisture_model
    soil_thermal_model
    environment_minmax
    environment_hourly = nothing
    environment_daily
    # intial conditions TODO: where to put these?
    initial_soil_temperature = fill(u"K"(7.741667u"°C"), length(depths))
    initial_soil_moisture = [0.42, 0.42, 0.42, 0.43, 0.44, 0.44, 0.43, 0.42, 0.41, 0.42, 0.42, 0.43]
    iterate_day = 3 # number of iterations per day
    # TODO: make these types so their code blocks can be removed by the compiler
    daily = false # doing consecutive days?
    runmoist = false # run soil moisture algorithm?
    spinup = false # spin-up the first day by iterate_day iterations?
end

function example_microclimate_problem(;
    latitude = 43.07305u"°",
    terrain=default_terrain(),
    soil_moisture_model=example_soil_moisture_model(),
    soil_thermal_model=example_soil_thermal_parameters(),
    environment_minmax=example_monthly_weather(),
    environment_daily=example_daily_environment(),
    kw...
)
    MicroProblem(; 
         latitude, terrain, soil_moisture_model, soil_thermal_model, environment_minmax, environment_daily, kw...
    )
end
# TODO 1. Needs the snow algorithm to be incorporated. The way I did this in the Fortran version was not
# elegant.
# TODO 2. Needs to dispatch differently depending on what combinations of hourly and daily forcing data
# are provided, which will be well defined when using different data sets e.g., ERA5, NCEP, SILO etc.,
# for which I have separate functions in NicheMapR, but needs to be more customisable for when local
# measured data is used (e.g., from a portable weather station)
# TODO 3. Now that it's easier to change the structure of the model, we should include the phase transition
# and soil moisture/snow calcululation in the solver so they are all solved togther (and ultimately the plant
# DEB model)
# TODO 4. Need to resolve the fact that soil temperature is computed with fewer nodes than soil moisture, where
# I added extra nodes at the mid points of the soil nodes, so 10 soil nodes and 19 soil moisture nodes, the 19th
# node being a constant (saturated) boundary condition. The root density is specified per node and so needs to
# generalise.
# TODO 5. Need to incorporate leap years.
# TODO 6. Dispatch differently depending on which scattered radiation algorithm, downwelling longwave radiation
# algorithm, vertical profile algorithm is being used
# TODO 7. Add an general function for computing cloud cover from solar radiation data (I have code for this in
# the different micro_ functions in NicheMapR - computes clear sky solar with SOLRAD and then compares the ratio
# of this with observed solar, e.g. daily integrated values as in AGCD/AWAP or hourly values as in ERA5)
# TODO 8. NeeLd to build in things currently done by Ilya's microclima package, e.g. downscaling NCEP/ERA5,
# computing diffuse and direct radiation
# TODO 9. Make it work on GPUs for rapid computation of grids, with intelligent initialisation based on near
# neighbours.

# TODO some of these can be actual defaults ?
function example_terrain(;
    elevation = 226.0u"m", # elevation (m)
    horizon_angles = fill(0.0u"°", 24), # enter the horizon angles (degrees) so that they go from 0 degrees azimuth (north) clockwise in 15 degree intervals
    slope = 0.0u"°", # slope (degrees, range 0-90)
    aspect = 0.0u"°", # aspect (degrees, 0 = North, range 0-360)
    # boundary layer parameters
    roughness_height = 0.004u"m", # heat transfer roughness height
    zh = 0u"m", #  heat transfer roughness height
    d0 = 0u"m", # zero plane displacement correction factor
    κ = 0.4, # Kármán constant
)
    Terrain(; elevation, horizon_angles, slope, aspect, roughness_height, zh, d0, κ)
end

function example_monthly_weather(;
    air_temperature_min = [-14.3, -12.1, -5.1, 1.2, 6.9, 12.3, 15.2, 13.6, 8.9, 3, -3.2, -10.6]u"°C",
    air_temperature_max = [-3.2, 0.1, 6.8, 14.6, 21.3, 26.4, 29, 27.7, 23.3, 16.6, 7.8, -0.4]u"°C",
    wind_min = [4.9, 4.8, 5.2, 5.3, 4.6, 4.3, 3.8, 3.7, 4, 4.6, 4.9, 4.8] * 0.1u"m/s",
    wind_max = [4.9, 4.8, 5.2, 5.3, 4.6, 4.3, 3.8, 3.7, 4, 4.6, 4.9, 4.8]u"m/s",
    humidity_min = [50.2, 48.4, 48.7, 40.8, 40, 42.1, 45.5, 47.3, 47.6, 45, 51.3, 52.8],
    humidity_max = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100],
    cloud_min = [50.3, 47, 48.2, 47.5, 40.9, 35.7, 34.1, 36.6, 42.6, 48.4, 61.1, 60.1],
    cloud_max = [50.3, 47, 48.2, 47.5, 40.9, 35.7, 34.1, 36.6, 42.6, 48.4, 61.1, 60.1],
    minima_times = (temp=0, wind=0, humidity=1, cloud=1), # time of minima for air temp, wind, humidity and cloud cover (h), air & wind mins relative to sunrise, humidity and cloud cover mins relative to solar noon
    maxima_times = (temp=1, wind=1, humidiy=0, cloud=0), # time of maxima for air temp, wind, humidity and cloud cover (h), air temp & wind maxs relative to solar noon, humidity and cloud cover maxs relative to sunrise
)
    MonthlyMinMaxWeather(air_temperature_min, air_temperature_max, wind_min, wind_max, humidity_min, humidity_max, cloud_min, cloud_max, minima_times, maxima_times)
end

function example_soil_thermal_parameters(;
    deVries_shape_factor = 0.1, # de Vries shape factor, 0.33 for organic soils, 0.1 for mineral
    soil_mineral_conductivity = 1.25u"W/m/K", # soil minerals thermal conductivity
    soil_mineral_density = 2.560u"Mg/m^3", # soil minerals density
    soil_mineral_heat_capacity = 870.0u"J/kg/K", # soil minerals specific heat
    soil_bulk_density = 2.56u"Mg/m^3", # dry soil bulk density
    # TODO why is this calculated elsewhere but also specified here
    soil_saturation_moisture = 0.26u"m^3/m^3", # volumetric water content at saturation (0.1 bar matric potential)
    recirculation_power = 4.0, # power for recirculation function
    return_flow_threshold = 0.162, # return-flow cutoff soil moisture, m^3/m^3
)
    CampbelldeVriesSoilThermal(
        deVries_shape_factor, soil_mineral_conductivity, soil_mineral_density, soil_mineral_heat_capacity,
        soil_bulk_density, soil_saturation_moisture, recirculation_power, return_flow_threshold
    )
end

# TODO move real defaults to the struct keywords
function example_soil_moisture_model(depths; 
    bulk_density,
    mineral_density,
    # soil moisture model soil parameters
    air_entry_water_potential = fill(0.7, length(depths) * 2 - 2)u"J/kg", #air entry potential
    saturated_hydraulic_conductivity = fill(0.0058, length(depths) * 2 - 2)u"kg*s/m^3", #saturated conductivity
    Campbells_b_parameter = fill(1.7, length(depths) * 2 - 2), #soil 'b' parameter
    soil_bulk_density2 = fill(bulk_density, length(depths) * 2 - 2)u"Mg/m^3", # soil bulk density
    # TODO what is this why are they different
    soil_mineral_density2 = fill(mineral_density, length(depths) * 2 - 2)u"Mg/m^3", # soil mineral density
    # soil moisture plant parameters
    root_density = [0, 0, 8.2, 8.0, 7.8, 7.4, 7.1, 6.4, 5.8, 4.8, 4.0, 1.8, 0.9, 0.6, 0.8, 0.4, 0.4, 0, 0] * 1e4u"m/m^3", # root density at each node (from Campell 1985 Soil Physics with Basic, p. 131)
    root_resistance = 2.5e+10u"m^3/kg/s", # resistance per unit length of root
    stomatal_closure_potential = -1500.0u"J/kg", # critical leaf water potential for stomatal closure
    leaf_resistance = 2.0e6u"m^4/kg/s", # resistance per unit length of leaf
    stomatal_stability_parameter = 10.0, # stability parameter, -
    root_radius = 0.001u"m", # root radius, m
    # soil moisture simulation controls
    moist_error = 1e-6u"kg/m^2/s", # maximum overall mass balance error allowed
    moist_count = 500, # maximum iterations of soil moisture algorithm
    moist_step = 360.0u"s", # time step over which to simulate soil moisture (< =  1 hour)
    maxpool = 1.0e4u"kg/m^2", # maximum depth of pooling water
)
    SoilMoistureModel(
        air_entry_water_potential, saturated_hydraulic_conductivity, Campbells_b_parameter, soil_bulk_density2,
        soil_mineral_density2, root_density, root_resistance, stomatal_closure_potential, leaf_resistance, stomatal_stability_parameter,
        root_radius, moist_error, moist_count, moist_step, maxpool
    )
end
function example_daily_environmental(;
    albedo = fill(0.1, length(days)), # substrate albedo (decimal %)
    shade = fill(0.0, length(days)), # % shade cast by vegetation
    soil_wetness = fill(0.0, length(days)), # % surface wetness
    surface_emissivity = fill(0.96, length(days)), # - surface emissivity
    rainfall = ([28, 28.2, 54.6, 79.7, 81.3, 100.1, 101.3, 102.5, 89.7, 62.4, 54.9, 41.2])u"kg/m^2",
    deep_soil_temperature = fill(7.741666u"°C", length(days)),
    leaf_area_index = fill(0.1, length(days)),
)
    EnvironmentTimeseries(; albedo, shade, soil_wetness, surface_emissivity, rainfall, deep_soil_temperature, leaf_area_index)
end

function solve(mp::MicroProblem)
    (; environment_minmax, environment_daily, environment_hourly, days, hours, depths, heights) = mp
    ndays = length(days)
    nhours = length(hours)
    nsteps = ndays * nhours
    numnodes_a = length(depths) # number of soil nodes for temperature calcs and final output

    # Solar
    solrad_out = solve_solar(mp)
    # Define the output
    output = MicroResult(nsteps, numnodes_a)
    # Interpolate minmax weather
    interpolate_minmax!(output, environment_minmax, environment_daily, environment_hourly, solrad_out)
    # Adjust solrad given cloud cover
    adjust_for_cloud_cover!(output, solrad_out, days, hours, environment_hourly)
    # Solve soil temperature and moisture
    solve_soil!(output, mp, solrad_out; days, hours, depths, heights)
    # Solve air temperatures, windspeed and humidity
    solve_air!(output, solrad_out, mp)

    # TODO what is all this wrangling for
    # flip2vectors(x) = (; (k => getfield.(x, k) for k in keys(x[1]))...)
    # profiles = flip2vectors(profile_out); # pull out each output as a vector
    # output.air_temperature .= reduce(hcat, profiles.air_temperatures)'
    # output.wind_speed .= reduce(hcat, profiles.wind_speeds)'
    # output.relative_humidity .= reduce(hcat, profiles.humidities)'

    return output
end

function solve_solar(mp::MicroProblem)
    (; solar_model, days, hours, latitude, terrain) = mp
    albedo = mp.environment_daily.albedo
    # compute clear sky solar radiation
    solrad_out = solrad(solar_model; days, hours, latitude, terrain, albedo)
    # limit max zenith angles to 90°
    # TODO: why doesn't this just happen in solrad?
    solrad_out.zenith_angle[solrad_out.zenith_angle .> 90u"°"] .= 90u"°"
    solrad_out.zenith_slope_angle[solrad_out.zenith_slope_angle .> 90u"°"] .= 90u"°"

    return solrad_out
end

# TODO: this function is pretty weird
# Why do we get 25 hour days from hourly_vars and then
# throw them away to just use the 24 hour days?
function interpolate_minmax!(output, environment_minmax, environment_daily, environment_hourly, solrad_out)
    # interpolate daily min/max forcing variables to hourly
    air_temperature, wind_speed, relative_humidity, cloud_cover = hourly_vars(environment_minmax, solrad_out)
    # TODO just use loops for these this allocates
    relative_humidity[relative_humidity .> 100] .= 100
    cloud_cover[cloud_cover .> 100] .= 100

    output.cloud_cover .= cloud_cover
    output.air_temperature .= air_temperature
    output.wind_speed .= wind_speed
    output.relative_humidity .= relative_humidity

    return 
end
function interpolate_minmax!(output, environment_minmax::Nothing, environment_daily, environment_hourly, solrad_out)
    output.cloud_cover .= environment_hourly.cloud_cover
    output.air_temperature .= environment_hourly.air_temperature
    output.wind_speed .= environment_hourly.wind_speed
    output.relative_humidity .= environment_hourly.relative_humidity

    return 
end

function adjust_for_cloud_cover!(output, solrad_out, days, hours, environment_hourly)
    # vector for removing extra interpolated hour TODO: this feels like a hack, there must be a better way
    zenith_angle = solrad_out.zenith_angle # remove every 25th output
    zenith_slope_angle = solrad_out.zenith_slope_angle # remove every 25th output
    # adjust for cloud using Angstrom formula (formula 5.33 on P. 177 of "Climate Data and Resources" by Edward Linacre 1992
    day_of_year = repeat(days, inner=length(hours))
    direct_total = solrad_out.direct_total # remove every 25th output
    diffuse_total = solrad_out.diffuse_total # remove every 25th output
    cloud_adjust_radiation!(output, output.cloud_cover ./ 100.0, diffuse_total, direct_total, zenith_angle, day_of_year)

    # TODO: this is awful, output.global_solar was also set above in `cloud_adjust_radiation!`
    # and why is global solar not called solar_radiation
    if !isnothing(environment_hourly)
        output.global_solar .= environment_hourly.solar_radiation
    end

    return output
end

# Solves soil temperature and moisture
function solve_soil!(output::MicroResult, mp::MicroProblem, solrad_out; 
    days, hours, depths, heights
)
    (; terrain, soil_thermal_model, soil_moisture_model, environment_minmax, environment_daily, daily, initial_soil_temperature, initial_soil_moisture, runmoist) = mp
    (; moist_step, Campbells_b_parameter, soil_bulk_density2, soil_mineral_density2, air_entry_water_potential) = soil_moisture_model
    

    ndays = length(days)
    nhours = length(hours)
    nsteps = ndays * nhours
    numnodes_a = length(depths) # number of soil nodes for temperature calcs and final output
    numnodes_b = numnodes_a * 2 - 2 # number of soil nodes for soil moisture calcs

    # initial conditions
    if !daily && !isnothing(initial_soil_temperature)
        t = mean(u"K", view(output.air_temperature, 1:nhours))
        initial_soil_temperature = SVector(ntuple(_ -> t, numnodes_a))
    end
    T0 = SVector{length(initial_soil_temperature)}(initial_soil_temperature)

    # Soil properties
    # set up a profile of soil properites with depth for each day to be run
    nodes_day = zeros(numnodes_a, ndays) # array of all possible soil nodes
    nodes_day[1, 1:ndays] .= numnodes_a # deepest node for first substrate type
    # These could also be vectors if we let users specify them
    ∑phase = zeros(typeof(1.0u"J"), numnodes_a) # zero phase transition for liquid water in soil

    # TODO make sure root density is interpolated from original values by default if number of
    # depth nodes is altered
    # if runmoist & length(depths) != 10
    #     depths_orig = [0.0, 2.5, 5.0, 10.0, 15.0, 20.0, 30.0, 40.0, 50.0, 100.0, 200.0]u"cm"
    #     mids_orig = [(depths_orig[i] + depths_orig[i+1]) / 2 for i in 1:length(depths_orig)-1]
    #     expanded_depths_orig = sort(unique([depths_orig; mids_orig]))
    #     mids = [(depths[i] + depths[i+1]) / 2 for i in 1:length(depths)-1]
    #     expanded_depths = sort(unique([depths; mids]))
    #     function spline_to_depths(base_depths, base_values, new_depths)
    #         # strip units for interpolation
    #         x = ustrip.(u"cm", base_depths)
    #         y = base_values ./ unit(base_values)  # plain numbers
    #         itp = LinearInterpolation(x, y, extrapolation_bc=Line())  # or CubicSplineInterpolation
    #         # evaluate at new depths
    #         y_new = itp.(ustrip.(u"cm", new_depths)) * unit(base_values)
    #         return y_new
    #     end
    #     L2 = spline_to_depths(expanded_depths, root_density, expanded_depths)
    # end
    (; θ_soil0_a, θ_soil0_b) = initialise_soil_moisture(initial_soil_moisture, numnodes_a, numnodes_b)

    # TODO did we set this
    # T_soils[1] = T0
    # θ_soils[1, :] = θ_soil0_a
    nodes = nodes_day[:, 1]
    M = 18 # soil_water_balance default
    buffers = (;
        profile = allocate_profile(heights),
        soil_energy_balance = allocate_soil_energy_balance(numnodes_b),  # only once
        soil_properties = allocate_soil_properties(nodes, soil_thermal_model),
        phase_transition = allocate_phase_transition(length(depths)),
        soil_water_balance = allocate_soil_water_balance(numnodes_b),  # only once
    )
    update_soil_properties!(output, buffers.soil_properties, soil_thermal_model;
        soil_temperature=T0, soil_moisture=θ_soil0_a, terrain, step=1
    )
    sub = vcat(findall(isodd, 1:numnodes_b), numnodes_b)

    soil_saturation_moisture = 1.0 .- soil_bulk_density2 ./ soil_mineral_density2
    output.soil_water_potential[1, :] .= air_entry_water_potential[sub] .* (soil_saturation_moisture[sub] ./ θ_soil0_a) .^ Campbells_b_parameter[sub]
    output.soil_temperature[1, :] .= T0
    output.soil_moisture[1, :] = θ_soil0_a

    if runmoist
        MW = 0.01801528u"kg/mol" # molar mass of water, kg/mol # TODO use UnitfulMoles
        output.soil_humidity[1, :] = clamp.(exp.(MW .* output.soil_water_potential[1, :] ./ (R .* T0)), 0, 1)
    end

    environment_day = get_day(environment_daily, 1)
    environment_instant = get_instant(environment_day, mp.environment_hourly, output, θ_soil0_a, 1)
    longwave_out = longwave_radiation(; terrain, surface_temperature=T0[1], environment_instant)

    # simulate all days
    pool = 0.0u"kg/m^2" # initialise depth of pooling water TODO make this an init option
    niter_moist = ustrip(u"s^-1", 3600 / moist_step) # TODO use a solver for soil moisture calc
    ∑phase = zeros(Float64, numnodes_a)u"J"
    infil_out = nothing
    soil_wetness = environment_instant.soil_wetness
    for j in 1:ndays
        iday = j
        nodes .= nodes_day[:, iday]
        environment_day = get_day(environment_daily, iday)
        forcing = forcing_day(solrad_out, output, iday)
        step = 1
        # loop through hours of day
        if mp.spinup && j == 1 || daily == false
            niter = mp.iterate_day # number of interations for steady periodic
        else
            niter = 1
        end
        if !daily
            ∑phase .= 0.0u"J"
            sub2 = (iday*nhours-nhours+1):(iday*nhours) # for getting mean monthly over the 25 hrs as in fortran version
            t = mean(u"K", output.air_temperature[sub2]) # make initial soil temps equal to mean annual temperature
            T0 = SVector(ntuple(_ -> t, numnodes_a))
            #T_soils[step, :] = T0
            θ_soil0_a = collect(fill(initial_soil_moisture[iday], numnodes_a)) # initial soil moisture
        end
        T0 = setindex(T0, environment_instant.deep_soil_temperature, numnodes_a) # set deepest node to boundary condition
        for iter = 1:niter
            for i in 1:length(hours)
                step = (j - 1) * length(hours) + i
                if i == 1 # make first hour of day equal last hour of previous iteration
                    # Then why do we run the soil water balance again??
                    output.soil_temperature[step, :] .= T0
                    pool += environment_instant.rainfall
                    if runmoist
                        infil_out, soil_wetness, pool, θ_soil0_b = get_soil_water_balance!(buffers, soil_moisture_model;
                            depths, heights, terrain, environment_instant, T0, niter_moist, soil_wetness, pool, soil_moisture=θ_soil0_b,
                        )
                        update_soil_water!(output, infil_out, sub, step)
                    end
                    pool = clamp(pool, 0.0u"kg/m^2", soil_moisture_model.maxpool)
                else
                    environment_instant = get_instant(environment_day, mp.environment_hourly, output, θ_soil0_a, step)
                    inputs = SoilEnergyInputs(; forcing, buffers, soil_thermal_model, depths, heights, terrain, runmoist, nodes, environment_instant)
                    soiltemps = get_soil_temp_timeline(T0, inputs, i)
                    # account for any phase transition of water in soil
                    T0 = soiltemps[2]
                    if iter == niter # this makes it the same as the R version but really this should happen every time
                        ∑phase, qphase, T0 = phase_transition!(buffers.phase_transition; Ts=soiltemps[2], T_past=soiltemps[1], ∑phase, θ=θ_soil0_a, depths)
                    end
                    output.soil_temperature[step, :] .= T0
                    if runmoist
                        infil_out, soil_wetness, pool, θ_soil0_b = get_soil_water_balance!(buffers, soil_moisture_model;
                            depths, heights, terrain, environment_instant, T0, niter_moist, pool, soil_wetness, soil_moisture=θ_soil0_b 
                        )
                        update_soil_water!(output, infil_out, sub, step)
                    end
                    # TODO: why use every second step what is this
                    sub = vcat(findall(isodd, 1:numnodes_b), numnodes_b)
                    θ_soil0_a = θ_soil0_b[sub]
                    longwave_out = longwave_radiation(; terrain, environment_instant, surface_temperature=T0[1])
                end
                # Write to output
                output.surface_water[step] = pool
                output.soil_temperature[step, :] .= T0
                output.sky_temperature[step] = longwave_out.Tsky
                update_soil_properties!(output, buffers.soil_properties, soil_thermal_model;
                    soil_temperature=T0, soil_moisture=θ_soil0_a, terrain, step
                )
            end
        end
    end

    return output
end

# compute air temperature, wind speed and relative humidity profiles
function solve_air!(output::MicroResult, solrad_out, mp::MicroProblem)
    (; heights, terrain) = mp
    profile_buffers = allocate_profile(heights)
    for i in 1:length(output.profile)
        # TODO standardise these names
        surface_temperature=u"°C"(output.soil_temperature[i][1])
        environment_instant = (;
            reference_temperature=output.air_temperature[i],
            reference_wind_speed=output.wind_speed[i],
            relative_humidity=output.relative_humidity[i],
            zenith_angle=solrad_out.zenith_angle[i],
        )
        # compute scalar profiles
        output.profile[i] = atmospheric_surface_profile!(profile_buffers; terrain, environment_instant, surface_temperature)
    end
end

function get_soil_temp_timeline(T0, input, i)
    tspan = ((0.0 + (i - 2) * 60)u"minute", (60.0 + (i - 2) * 60)u"minute")  # 1 hour
    prob = ODEProblem{false}(soil_energy_balance, T0, tspan, input)
    sol = SciMLBase.solve(prob, Tsit5(); saveat=60.0u"minute", reltol=1e-6u"K", abstol=1e-8u"K")
    return sol.u
end

function update_soil_properties!(output, soil_properties_buffers, soil_thermal_model; step, kw...)
    (; λ_b, cp_b, ρ_b) = soil_properties!(soil_properties_buffers, soil_thermal_model; kw...)

    output.soil_thermal_conductivity[step, :] .= λ_b
    output.soil_specific_heat[step, :] .= cp_b
    output.soil_bulk_density[step, :] .= ρ_b

    return output
end

function update_soil_water!(output, infil_out, sub, step)
    output.soil_moisture[step, :] .= infil_out.θ_soil[sub]
    output.soil_water_potential[step, :] .= infil_out.ψ_soil[sub]
    output.soil_humidity[step, :] .= infil_out.rh_soil[sub]

    return output
end

# TODO eventually make environment a type,
# and this can just be `getindex` on that type.
function forcing_day(solrad_out, output, iday::Int)
    (; air_temperature, wind_speed, relative_humidity, cloud_cover) = output
    # TODO: rename this
    solar_radiation = output.global_solar
    (; zenith_angle, zenith_slope_angle) = solrad_out

    nhours = 24
    sub1 = (iday*nhours-nhours+1):(iday*nhours)
    tspan = 0.0:60:(60*nhours)

    # get today's weather
    SOLR = solar_radiation[sub1]
    ZENR = zenith_angle[sub1]
    ZSL = zenith_slope_angle[sub1]
    TAIR = air_temperature[sub1]
    VEL = wind_speed[sub1]
    RH = relative_humidity[sub1]
    CLD = cloud_cover[sub1]

    interpSOLR = interpolate([SOLR; SOLR[end]], BSpline(Linear()))
    interpZENR = interpolate([ZENR; ZENR[end]], BSpline(Linear()))
    interpZSL = interpolate([ZSL; ZSL[end]], BSpline(Linear()))
    interpTAIR = interpolate(u"K".([TAIR; TAIR[end]]), BSpline(Linear()))
    interpVEL = interpolate([VEL; VEL[end]], BSpline(Linear()))
    interpRH = interpolate([RH; RH[end]], BSpline(Linear()))
    interpCLD = interpolate([CLD; CLD[end]], BSpline(Linear()))

    SOLRt = scale(interpSOLR, tspan)
    ZENRt = scale(interpZENR, tspan)
    ZSLt = scale(interpZSL, tspan)
    TAIRt = scale(interpTAIR, tspan)
    VELt = scale(interpVEL, tspan)
    RHt = scale(interpRH, tspan)
    CLDt = scale(interpCLD, tspan)

    return MicroForcing(; SOLRt, ZENRt, ZSLt, TAIRt, VELt, RHt, CLDt)
end

function initialise_soil_moisture(initial_soil_moisture, numnodes_a, numnodes_b)
    θ_soil0_a = collect(fill(initial_soil_moisture[1], numnodes_a)) # initial soil moisture
    θ_soil0_b = similar(θ_soil0_a, numnodes_b)  # preallocate vector of length numnodes_b
    jj = 1
    for ii in 1:numnodes_b
        if isodd(ii)
            θ_soil0_b[ii] = θ_soil0_a[jj]
            jj += 1
        else
            θ_soil0_b[ii] = θ_soil0_b[ii-1]
        end
    end

    return (; θ_soil0_a, θ_soil0_b)
end

# TODO these functions are a bit silly
function get_day(environment_daily, iday)
    # TODO: standardise all these names
    surface_emissivity = environment_daily.surface_emissivity[iday] # set up vector of ground emissivities for each day
    environment_day = (;
        leaf_area_index = environment_daily.leaf_area_index[iday],
        albedo = environment_daily.albedo[iday],
        shade = environment_daily.shade[iday], # daily shade (%)
        surface_emissivity,
        # TODO why is this ok
        cloud_emissivity = surface_emissivity, # - cloud emissivity
        soil_wetness = environment_daily.soil_wetness[iday], # set up vector of soil wetness for each day
        deep_soil_temperature = u"K"(environment_daily.deep_soil_temperature[iday]), # daily deep soil temperature (°C)
        rainfall = environment_daily.rainfall[iday],
    )
end
function get_instant(environment_day, environment_hourly, output, θ_soil0_a, i)
    return (;
        environment_day...,
        # TODO getting data from output means it being correct depends on
        # order of operations in the solve. We need an itermediate object instead
        air_temperature = output.air_temperature[i],
        # TODO are these always the same thing?
        reference_temperature=output.air_temperature[i],
        wind_speed = output.wind_speed[i],
        # TODO consolidate these
        reference_wind_speed=output.wind_speed[i],
        relative_humidity = output.relative_humidity[i],
        zenith_angle = output.zenith_angle[i],
        cloud_cover = output.cloud_cover[i],
        solar_radiation = output.global_solar[i],
        soil_moisture=θ_soil0_a,
    )
end

# This handles getting values from a Number or array of numbers, or objects of these
maybegetindex(obj::CampbelldeVriesSoilThermal, i::Int) = CampbelldeVriesSoilThermal(; maybegetindex(ConstructionBase.getproperties(obj), i)...)
maybegetindex(props::NamedTuple, i::Int) = map(p -> maybegetindex(p, i), props)
maybegetindex(val::Number, i::Int) = val
maybegetindex(vals::AbstractArray, i::Int) = vals[i]
