"""
    runmicro(...)

Simulates soil and microclimate dynamics over multiple days.

# Overview generated by ChatGPT
- Interpolates daily min/max weather (temperature, wind, humidity, cloud) 
  to hourly steps.
- Solves the soil energy balance using an ODE each hour.
- Optionally simulates soil moisture (`runmoist=true`).
- Returns detailed outputs for soil, air, radiation, and water balance.

# Hourly Weather Interpolation
- Daily min/max values are interpolated to 25-hour vectors 
  (e.g. `TAIRs25`).
- Every 25th value is removed (`skip25`) → 24 hours per day.
- Matches the Fortran/R approach where an extra hour smooths 
  interpolation.

# Soil Layer Setup
- `numnodes_a`: number of nodes for temperature output.
- `numnodes_b`: expanded nodes for moisture (`numnodes_a * 2 - 2`).
- Initializes temperature (`θ_soil0_a`) and moisture (`θ_soil0_b`).
- Tracks water phase transitions in `Σphase`.

# Solar Radiation
- `solrad` computes clear-sky radiation.
- Zenith angles capped at 90°.
- Clouds adjust radiation with `cloud_adjust_radiation`.

# Time Loop
- Outer loop: days.
- Inner loop: hours.
- Supports spin-up or multi-iteration (`iterate_day`).
- Each hour:
  * `soil_energy_balance!` updates temperature.
  * `get_soil_water_balance` updates moisture (optional).
  * Soil properties (`λ_bulk`, `c_p_bulk`, `ρ_bulk`) updated.
  * Sky temperature computed with `get_longwave`.

# Profiles
- After all days, computes air, wind, humidity profiles 
  via `get_profile`.
- Results are "flipped" into vectors with `flip2vectors`.

# Return Values
Returns a named tuple containing:
- Air/wind/RH profiles
- Cloud cover and solar radiation
- Soil temperature, moisture, water potential, RH
- Soil thermal properties and bulk density
- Surface water pools
- `solrad_out` and `profile_out` for detailed internals

# Notes
- **Units**: Uses `Unitful.jl`. Ensure all functions 
  preserve units.
- **Memory**: Large arrays (`T_soils`, `θ_soils`) 
  may be heavy for long runs.
- **Interpolation**: Extra 25th hour is correct but 
  needs careful indexing.
- **Phase transitions**: Applied hourly; check 
  `Σphase` across multi-day runs.
- **Moisture logic**: Updates depend on 
  `i == 1` or `i < length(hours)`; confirm 
  matches Fortran/R logic.
"""
# TODO 1. Needs the snow algorithm to be incorporated. The way I did this in the Fortran version was not
# elegant.
# TODO 2. Needs to dispatch differently depending on what combinations of hourly and daily forcing data
# are provided, which will be well defined when using different data sets e.g., ERA5, NCEP, SILO etc.,
# for which I have separate functions in NicheMapR, but needs to be more customisable for when local
# measured data is used (e.g., from a portable weather station)
# TODO 3. Now that it's easier to change the structure of the model, we should include the phase transition
# and soil moisture/snow calcululation in the solver so they are all solved togther (and ultimately the plant
# DEB model)
# TODO 4. Need to resolve the fact that soil temperature is computed with fewer nodes than soil moisture, where
# I added extra nodes at the mid points of the soil nodes, so 10 soil nodes and 19 soil moisture nodes, the 19th
# node being a constant (saturated) boundary condition. The root density is specified per node and so needs to
# generalise.
# TODO 5. Need to incorporate leap years.
# TODO 6. Dispatch differently depending on which scattered radiation algorithm, downwelling longwave radiation
# algorithm, vertical profile algorithm is being used
# TODO 7. Add an general function for computing cloud cover from solar radiation data (I have code for this in
# the different micro_ functions in NicheMapR - computes clear sky solar with SOLRAD and then compares the ratio
# of this with observed solar, e.g. daily integrated values as in AGCD/AWAP or hourly values as in ERA5)
# TODO 8. Need to build in things currently done by Ilya's microclima package, e.g. downscaling NCEP/ERA5, 
# computing diffuse and direct radiation
# TODO 9. Make it work on GPUs for rapid computation of grids, with intelligent initialisation based on near
# neighbours.

function runmicro(;
    # locations, times, depths and heights
    latitude = 43.07305u"°", # latitude
    days = [15, 46, 74, 105, 135, 166, 196, 227, 258, 288, 319, 349], # days of year to simulate - TODO leap years
    hours = collect(0.:1:24.), # hour of day for solrad
    depths = [0.0, 2.5, 5.0, 10.0, 15.0, 20.0, 30.0, 40.0, 50.0, 100.0, 200.0]u"cm", # soil nodes - keep spacing close near the surface
    heights = [0.01, 2]u"m", # air nodes for temperature, wind speed and humidity profile, last height is reference height for weather data
    # solar radiation
    cmH2O = 1, # precipitable cm H2O in air column, 0.1 = very dry; 1 = moist air conditions; 2 = humid, tropical conditions (note this is for the whole atmospheric profile, not just near the ground)
    ϵ = 0.0167238, # orbital eccentricity of Earth
    ω = 2π / 365, # mean angular orbital velocity of Earth (radians/day)
    se = 0.39784993, # precomputed solar elevation constant
    d0_solrad = 80.0, # reference day for declination calculations
    iuv = false, # if `true`, uses the full gamma-function model for diffuse radiation (expensive)
    scattered = true, # if `false`, disables scattered light computations (faster)
    amr = 25.0u"km", # mixing ratio height of the atmosphere
    nmax = 111, # Maximum number of wavelength intervals
    Iλ = DEFAULT_Iλ, # cector of wavelength bins (e.g. in `nm`)
    OZ = DEFAULT_OZ, # ozone column depth table indexed by latitude band and month (size 19×12)
    τR = DEFAULT_τR, # vector of optical depths per wavelength for Rayleigh scattering
    τO = DEFAULT_τO, # vector of optical depths per wavelength for ozone
    τA = DEFAULT_τA, # vector of optical depths per wavelength for aerosols
    τW = DEFAULT_τW, # vector of optical depths per wavelength for water vapor
    Sλ = DEFAULT_Sλ, # solar spectral irradiance per wavelength bin (e.g. in `mW * cm^-2 * nm^-1`)
    FD = DEFAULT_FD, # interpolated functino of radiation scattered from the direct solar beam
    FDQ = DEFAULT_FDQ, # interpolated function of radiation scattered from ground-reflected radiation
    s̄ = DEFAULT_s̄, # a function of τR linked to molecular scattering in the UV range (< 360 nm)
    # terrain
    elevation = 226.0u"m", # elevation (m)
    horizon_angles = fill(0.0u"°", 24), # enter the horizon angles (degrees) so that they go from 0 degrees azimuth (north) clockwise in 15 degree intervals
    slope = 0.0u"°", # slope (degrees, range 0-90)
    aspect = 0.0u"°", # aspect (degrees, 0 = North, range 0-360)
    roughness_height = 0.004u"m", # heat transfer roughness height
    zh = 0u"m", #  heat transfer roughness height
    d0 = 0u"m", # zero plane displacement correction factor
    κ = 0.4, # Kármán constant 
    # soil thermal parameters 
    soil_mineral_conductivity = 1.25u"W/m/K", # soil minerals thermal conductivity
    soil_mineral_density = 2.560u"Mg/m^3", # soil minerals density
    soil_mineral_heat_capacity = 870.0u"J/kg/K", # soil minerals specific heat
    soil_bulk_density = 2.56u"Mg/m^3", # dry soil bulk density
    soil_saturation_moisture = 0.26u"m^3/m^3", # volumetric water content at saturation (0.1 bar matric potential)
    # soil moisture model soil parameters
    air_entry_water_potential = fill(0.7, length(depths) * 2 - 2)u"J/kg", #air entry potential
    saturated_hydraulic_conductivity = fill(0.0058, length(depths) * 2 - 2)u"kg*s/m^3", #saturated conductivity
    Campbells_b_parameter = fill(1.7, length(depths) * 2 - 2), #soil 'b' parameter
    soil_bulk_density2 = fill(soil_bulk_density, length(depths) * 2 - 2)u"Mg/m^3", # soil bulk density
    soil_mineral_density2 = fill(soil_mineral_density, length(depths) * 2 - 2)u"Mg/m^3", # soil mineral density
    # soil moisture plant parameters
    root_density = [0, 0, 8.2, 8.0, 7.8, 7.4, 7.1, 6.4, 5.8, 4.8, 4.0, 1.8, 0.9, 0.6, 0.8, 0.4, 0.4, 0, 0] * 1e4u"m/m^3", # root density at each node (from Campell 1985 Soil Physics with Basic, p. 131)
    root_resistance = 2.5e+10u"m^3/kg/s", # resistance per unit length of root
    stomatal_closure_potential = -1500.0u"J/kg", # critical leaf water potential for stomatal closure
    leaf_resistance = 2.0e6u"m^4/kg/s", # resistance per unit length of leaf
    stomatal_stability_parameter = 10.0, # stability parameter, -
    root_radius = 0.001u"m", # root radius, m
    # soil moisture simulation controls
    moist_error = 1e-6u"kg/m^2/s", # maximum overall mass balance error allowed
    moist_count = 500, # maximum iterations of soil moisture algorithm
    moist_step = 360.0u"s", # time step over which to simulate soil moisture (< =  1 hour)
    maxpool = 1.0e4u"kg/m^2", # maximum depth of pooling water
    # daily environmental vectors
    albedos = fill(0.1, length(days)), # substrate albedo (decimal %)
    shades = fill(0.0, length(days)), # % shade cast by vegetation
    pctwets = fill(0.0, length(days)), # % surface wetness
    sles = fill(0.96, length(days)), # - surface emissivity
    # TODO its dangerous having these as defaults.
    daily_rainfall = ([28, 28.2, 54.6, 79.7, 81.3, 100.1, 101.3, 102.5, 89.7, 62.4, 54.9, 41.2])u"kg/m^2",
    air_temperature_min = ([-14.3, -12.1, -5.1, 1.2, 6.9, 12.3, 15.2, 13.6, 8.9, 3, -3.2, -10.6] * 1.0)u"°C",
    air_temperature_max = ([-3.2, 0.1, 6.8, 14.6, 21.3, 26.4, 29, 27.7, 23.3, 16.6, 7.8, -0.4] * 1.0)u"°C",
    wind_min = ([4.9, 4.8, 5.2, 5.3, 4.6, 4.3, 3.8, 3.7, 4, 4.6, 4.9, 4.8] * 0.1)u"m/s",
    wind_max = ([4.9, 4.8, 5.2, 5.3, 4.6, 4.3, 3.8, 3.7, 4, 4.6, 4.9, 4.8] * 1.0)u"m/s",
    humidity_min = [50.2, 48.4, 48.7, 40.8, 40, 42.1, 45.5, 47.3, 47.6, 45, 51.3, 52.8],
    humidity_max = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100],
    cloud_min = [50.3, 47, 48.2, 47.5, 40.9, 35.7, 34.1, 36.6, 42.6, 48.4, 61.1, 60.1],
    cloud_max = [50.3, 47, 48.2, 47.5, 40.9, 35.7, 34.1, 36.6, 42.6, 48.4, 61.1, 60.1],
    minima_times = [0, 0, 1, 1], # time of minima for air temp, wind, humidity and cloud cover (h), air & wind mins relative to sunrise, humidity and cloud cover mins relative to solar noon
    maxima_times = [1, 1, 0, 0], # time of maxima for air temp, wind, humidity and cloud cover (h), air temp & wind maxs relative to solar noon, humidity and cloud cover maxs relative to sunrise
    deep_soil_temperatures = fill(7.741666u"°C", length(days)),
    # hourly weather vectors
    air_temperatures = nothing,
    humidities = nothing,
    wind_speeds = nothing,
    solar_radiation = nothing,
    cloud_covers = nothing,
    RAINs = nothing,
    zenith_angles = nothing,
    longwave_radiation = nothing,
    # intial conditions
    initial_soil_temperature = fill(u"K"(7.741667u"°C"), length(depths)),
    initial_soil_moisture = [0.42, 0.42, 0.42, 0.43, 0.44, 0.44, 0.43, 0.42, 0.41, 0.42, 0.42, 0.43],
    leaf_area_index = fill(0.1, length(days)),
    iterate_day = 3, # number of iterations per day
    maximum_surface_temperature = u"K"(85.0u"°C"),
    daily = false, # doing consecutive days?
    runmoist = false, # run soil moisture algorithm?
    spinup = false, # spin-up the first day by iterate_day iterations?
    __n::Val{N} = Val{length(depths)}() # This is a tiny hack so N is known to the compiler in function body
) where N

    #reference_height = last(heights)
    ndays = length(days)
    # defining view factor for sky radiation based on horizon angles
    viewfactor = 1 - sum(sin.(horizon_angles)) / length(horizon_angles) # convert horizon angles to radians and calc view factor(s)

    # Soil properties
    # set up a profile of soil properites with depth for each day to be run
    numnodes_a = N # number of soil nodes for temperature calcs and final output
    numnodes_b = numnodes_a * 2 - 2 # number of soil nodes for soil moisture calcs
    nodes_day = zeros(numnodes_a, ndays) # array of all possible soil nodes
    nodes_day[1, 1:ndays] .= numnodes_a # deepest node for first substrate type
    # Create vectors of soil properties
    soilprops = (; 
        ρ_dry =  fill(soil_bulk_density, numnodes_a),
        θ_sat = fill(soil_saturation_moisture, numnodes_a),
        λ_m = fill(soil_mineral_conductivity, numnodes_a),
        cp_m = fill(soil_mineral_heat_capacity, numnodes_a),
        ρ_m = fill(soil_mineral_density, numnodes_a),
    )
    ∑phase = zeros(Float64, numnodes_a)u"J" # zero phase transition for liquid water in soil

    # compute clear sky solar radiation
    solrad_out = solrad(;
        days,
        hours,
        latitude,
        elevation,
        slope,
        aspect,
        horizon_angles,
        albedos,
        cmH2O,
        ϵ,
        ω,
        se,
        d0 = d0_solrad, #TODO better name for this
        iuv,
        scattered,
        amr,
        nmax,
        Iλ,
        OZ,
        τR,
        τO,
        τA,
        τW,
        Sλ, 
        FD,
        FDQ,
        s̄,
    )
    # limit max zenith angles to 90°
    solrad_out.zenith_angle[solrad_out.zenith_angle.>90u"°"] .= 90u"°"
    solrad_out.zenith_slope_angle[solrad_out.zenith_slope_angle.>90u"°"] .= 90u"°"

    # vector for removing extra interpolated hour
    skip25 = setdiff(1:length(solrad_out.zenith_angle), 25:25:length(solrad_out.zenith_angle))

    optional = (air_temperatures, humidities, wind_speeds, cloud_covers)
    optional_names = (:air_temperatures, :humidities, :wind_speeds, :solar_radiation, :cloud_covers, :RAINs)
    not_present = map(isnothing, optional)
    if any(not_present)
        all(not_present) || throw(ArgumentError("missing optional component $(optional_names[collect(not_present)])"))
        # interpolate daily min/max forcing variables to hourly
        TAIRs25, VELs25, RHs25, CLDs25 = hourly_vars(
            air_temperature_min,
            air_temperature_max,
            wind_min,
            wind_max,
            humidity_min,
            humidity_max,
            cloud_min,
            cloud_max,
            solrad_out,
            minima_times,
            maxima_times,
            daily
        )
        RHs25[RHs25.>100] .= 100
        CLDs25[CLDs25.>100] .= 100
        air_temperatures = TAIRs25[skip25] # remove every 25th output
        wind_speeds = VELs25[skip25] # remove every 25th output
        humidities = RHs25[skip25] # remove every 25th output
        cloud_covers = CLDs25[skip25] # remove every 25th output
    end
    zenith_angles = solrad_out.zenith_angle[skip25] # remove every 25th output
    zenith_slope_angle = solrad_out.zenith_slope_angle[skip25] # remove every 25th output
    # adjust for cloud using Angstrom formula (formula 5.33 on P. 177 of "Climate Data and Resources" by Edward Linacre 1992
    day_of_year  = repeat(days, inner=length(hours))[skip25]
    direct_total = solrad_out.direct_total[skip25] # remove every 25th output
    diffuse_total = solrad_out.diffuse_total[skip25] # remove every 25th output
    global_solar, diffuse_solar, direct_solar = cloud_adjust_radiation(cloud_covers / 100., diffuse_total, direct_total, zenith_angles, day_of_year)
    if isnothing(solar_radiation)
        solar_radiation = global_solar
    else
        global_solar = solar_radiation # keep global solar output as original solar radiation input
    end

    # TODO make sure root density is interpolated from original values by default if number of
    # depth nodes is altered
    # if runmoist & length(depths) != 10
    #     depths_orig = [0.0, 2.5, 5.0, 10.0, 15.0, 20.0, 30.0, 40.0, 50.0, 100.0, 200.0]u"cm"
    #     mids_orig = [(depths_orig[i] + depths_orig[i+1]) / 2 for i in 1:length(depths_orig)-1]
    #     expanded_depths_orig = sort(unique([depths_orig; mids_orig]))
    #     mids = [(depths[i] + depths[i+1]) / 2 for i in 1:length(depths)-1]
    #     expanded_depths = sort(unique([depths; mids]))
    #     function spline_to_depths(base_depths, base_values, new_depths)
    #         # strip units for interpolation
    #         x = ustrip.(u"cm", base_depths)
    #         y = base_values ./ unit(base_values)  # plain numbers
    #         itp = LinearInterpolation(x, y, extrapolation_bc=Line())  # or CubicSplineInterpolation
    #         # evaluate at new depths
    #         y_new = itp.(ustrip.(u"cm", new_depths)) * unit(base_values)
    #         return y_new
    #     end
    #     L2 = spline_to_depths(expanded_depths, root_density, expanded_depths)
    # end

    # initial conditions
    if !daily && !isnothing(initial_soil_temperature)
        t = mean(u"K", view(TAIRs25, 1:25))
        initial_soil_temperature = SVector(ntuple(_ -> t, numnodes_a))
    end
    soillayers = init_soillayers(numnodes_b)  # only once
    θ_soil0_a = collect(fill(initial_soil_moisture[1], numnodes_a)) # initial soil moisture
    θ_soil0_b = similar(θ_soil0_a, numnodes_b)  # preallocate vector of length numnodes_b
    jj = 1
    for ii in 1:numnodes_b
        if isodd(ii)
            θ_soil0_b[ii] = θ_soil0_a[jj]
            jj += 1
        else
            θ_soil0_b[ii] = θ_soil0_b[ii-1]
        end
    end

    # initialise outputs
    T0 = SVector{N}(initial_soil_temperature)

    # output arrays
    nsteps = ndays * (length(hours) - 1)
    T_soils = Array{typeof(T0)}(undef, nsteps)
    θ_soils = Array{Float64}(undef, nsteps, numnodes_a)
    ψ_soils = Array{Float64}(undef, nsteps, numnodes_a)u"J/kg"
    rh_soils = Array{Float64}(undef, nsteps, numnodes_a)
    λ_bulk = Array{Float64}(undef, nsteps, numnodes_a)u"W/m/K"
    c_p_bulk = Array{Float64}(undef, nsteps, numnodes_a)u"J/kg/K"
    ρ_bulk = Array{Float64}(undef, nsteps, numnodes_a)u"kg/m^3"
    pools = Array{Float64}(undef, nsteps)u"kg/m^2"
    T_skys = Array{Float64}(undef, nsteps)u"K"

    T_soils[1] = T0
    θ_soils[1, :] = θ_soil0_a
    nodes = nodes_day[:, 1]
    M = 18 # soil_water_balance default
    soil_properties_buffers = allocate_soil_properties(nodes, soilprops)
    phase_transition_buffers = allocate_phase_transition(length(depths))
    λ_b, c_p_b, ρ_b = soil_properties!(soil_properties_buffers, T0, θ_soil0_a, nodes, soilprops, elevation, runmoist, false)
    λ_bulk[1, :] = λ_b
    c_p_bulk[1, :] = c_p_b
    ρ_bulk[1, :] = ρ_b
    sub = vcat(findall(isodd, 1:numnodes_b), numnodes_b)
    soil_saturation_moisture = 1.0 .- soil_bulk_density2 ./ soil_mineral_density2
    ψ_soils[1, :] = air_entry_water_potential[sub] .* (soil_saturation_moisture[sub] ./ θ_soil0_a) .^ Campbells_b_parameter[sub]
    MW = 0.01801528u"kg/mol" # molar mass of water, kg/mol # TODO use UnitfulMoles
    rh_soils[1, :] = clamp.(exp.(MW .* ψ_soils[1, :] ./ (R .* T0)), 0, 1)
    pools[1] = 0.0u"kg/m^2"
    
    # sky temperature given cloud cover, shade, hillshade (viewfactor)
    # air temperature and humidity TODO have two options, Swinbank and Campbell
    longwave_out = get_longwave(;
        elevation,
        rh=humidities[1],
        tair=air_temperatures[1],
        tsurf=T0[1],
        slep=sles[1],
        sle=sles[1],
        cloud=cloud_covers[1],
        viewfactor=viewfactor,
        shade=shades[1]
    )
    Tsky = longwave_out.Tsky
    T_skys[1] = Tsky

    # simulate all days
    pool = 0.0u"kg/m^2" # initialise depth of pooling water TODO make this an init option
    heights_water_balance = heights
    soil_water_balance_buffers = allocate_soil_water_balance(numnodes_b)  # only once
    niter_moist = ustrip(3600 / moist_step) # TODO use a solver for soil moisture calc
    ∑phase = zeros(Float64, numnodes_a)u"J"
    infil_out = nothing
    for j in 1:ndays
        #j = 1
        iday = j
        lai = leaf_area_index[iday]
        albedo = albedos[iday]
        shade = shades[iday] # daily shade (%)
        sle = sles[iday] # set up vector of ground emissivities for each day
        slep = sle # - cloud emissivity
        pctwet = pctwets[iday] # set up vector of soil wetness for each day
        tdeep = u"K"(deep_soil_temperatures[iday]) # daily deep soil temperature (°C)
        nodes .= nodes_day[:, iday]
        rainfall = daily_rainfall[iday]
        # get today's weather
        sub1 = (iday*24-24+1):(iday*24)
        SOLR = solar_radiation[sub1]
        ZENR = zenith_angles[sub1]
        ZSL = zenith_slope_angle[sub1]
        TAIR = air_temperatures[sub1]
        VEL = wind_speeds[sub1]
        RH = humidities[sub1]
        CLD = cloud_covers[sub1]
        tspan = 0.0:60:(60*24)
        interpSOLR = interpolate([SOLR; SOLR[end]], BSpline(Linear()))
        interpZENR = interpolate([ZENR; ZENR[end]], BSpline(Linear()))
        interpZSL = interpolate([ZSL; ZSL[end]], BSpline(Linear()))
        interpTAIR = interpolate(u"K".([TAIR; TAIR[end]]), BSpline(Linear()))
        interpVEL = interpolate([VEL; VEL[end]], BSpline(Linear()))
        interpRH = interpolate([RH; RH[end]], BSpline(Linear()))
        interpCLD = interpolate([CLD; CLD[end]], BSpline(Linear()))
        SOLRt = scale(interpSOLR, tspan)
        ZENRt = scale(interpZENR, tspan)
        ZSLt = scale(interpZSL, tspan)
        TAIRt = scale(interpTAIR, tspan)
        VELt = scale(interpVEL, tspan)
        RHt = scale(interpRH, tspan)
        CLDt = scale(interpCLD, tspan)

        # Parameters
        params = MicroParams(;
            soilprops,
            depths,
            heights,
            roughness_height,
            d0,
            zh,
            κ,
            slope,
            shade,
            viewfactor,
            elevation,
            albedo,
            sle,
            slep, # check if this is what it should be - sle vs. slep (set as 1 in PAR in Fortran but then changed to user SLE later)
            pctwet,
            nodes,
            tdeep,
            θ_soil=θ_soil0_a,
            runmoist,
            maximum_surface_temperature,
        )
        forcing = MicroForcing(;
            SOLRt,
            ZENRt,
            ZSLt,
            TAIRt,
            VELt,
            RHt,
            CLDt,
        )
        buffers = (; soil_properties=soil_properties_buffers)
        input = MicroInputs(; params, forcing, soillayers, buffers)
        step = 1
        # loop through hours of day
        if spinup && j == 1 && i == 1 || daily == false
            niter = iterate_day # number of interations for steady periodic
        else
            niter = 1
        end
        if daily == false
            ∑phase = zeros(Float64, numnodes_a)u"J"
            sub2 = (iday*25-25+1):(iday*25) # for getting mean monthly over the 25 hrs as in fortran version
            t = u"K"(mean(ustrip(TAIRs25[sub2]))u"°C") # make initial soil temps equal to mean annual temperature
            T0 = SVector(ntuple(_ -> t, numnodes_a))
            #T_soils[step, :] = T0
            θ_soil0_a = collect(fill(initial_soil_moisture[iday], numnodes_a)) # initial soil moisture
        end

        @inbounds for iter = 1:niter
            for i in 1:length(hours)
                if i < length(hours)
                    step = (j - 1) * (length(hours) - 1) + i
                end
                if i == 1 # make first hour of day equal last hour of previous iteration
                    T_soils[step] = T0
                    step = (j - 1) * (length(hours) - 1) + i
                    pool += rainfall
                    if runmoist
                        infil_out, pctwet, pool, θ_soil0_b = get_soil_water_balance!(soil_water_balance_buffers;
                                roughness_height,
                                zh,
                                d0,
                                κ,
                                TAIRs = air_temperatures,
                                VELs = wind_speeds,
                                RHs = humidities,
                                ZENRs = zenith_angles,
                                T0,
                                heights = heights_water_balance,
                                elevation,
                                pool,
                                θ_soil0_b,
                                PE = air_entry_water_potential,
                                KS = saturated_hydraulic_conductivity,
                                BB = Campbells_b_parameter,
                                BD = soil_bulk_density2,
                                DD = soil_mineral_density2,
                                depths,
                                moist_step,
                                L = root_density,
                                rw = root_resistance,
                                pc = stomatal_closure_potential,
                                rl = leaf_resistance,
                                sp = stomatal_stability_parameter,
                                r1 = root_radius,
                                lai,
                                im = moist_error,
                                moist_count,
                                niter_moist,
                                pctwet,
                                step,
                                maxpool,
                                M,
                                maximum_surface_temperature,
                        )
                    end
                    pools[step] = pool
                    pool = clamp(pool, 0.0u"kg/m^2", maxpool)
                    T_skys[step] = Tsky
                    λ_b, c_p_b, ρ_b = soil_properties!(soil_properties_buffers, T0, θ_soil0_a, nodes, soilprops, elevation, runmoist, false)
                    λ_bulk[step, :] = λ_b
                    c_p_bulk[step, :] = c_p_b
                    ρ_bulk[step, :] = ρ_b
                    if runmoist && iday > 1
                        θ_soils[step, :] = infil_out.θ_soil[sub]
                        ψ_soils[step, :] = infil_out.ψ_soil[sub]
                        rh_soils[step, :] = infil_out.rh_soil[sub]
                    end
                else
                    # Parameters
                    params = MicroParams(;
                        soilprops,
                        depths,
                        heights,
                        roughness_height,
                        d0,
                        zh,
                        κ,
                        slope,
                        shade,
                        viewfactor,
                        elevation,
                        albedo,
                        sle,
                        slep,
                        pctwet,
                        nodes,
                        tdeep,
                        θ_soil=θ_soil0_a,
                        runmoist,
                        maximum_surface_temperature,
                    )
                    input = MicroInputs(params, forcing, soillayers, buffers)
                    tspan = ((0.0 + (i - 2) * 60)u"minute", (60.0 + (i - 2) * 60)u"minute")  # 1 hour
                    prob = ODEProblem{false}(soil_energy_balance, T0, tspan, input)
                    sol = solve(prob, Tsit5(); saveat=60.0u"minute", reltol=1e-6u"K", abstol=1e-8u"K")
                    soiltemps = sol.u
                    # account for any phase transition of water in soil
                    T0 = soiltemps[2]
                    if iter == niter # this makes it the same as the R version but really this should happen every time
                        ∑phase, qphase, T0 = phase_transition!(phase_transition_buffers; Ts=soiltemps[2], T_past=soiltemps[1], ∑phase, θ=θ_soil0_a, depths)
                    end
                    if i < length(hours)
                        T_soils[step] = T0
                    end
                    if runmoist
                        infil_out, pctwet, pool, θ_soil0_b = get_soil_water_balance!(soil_water_balance_buffers;
                                roughness_height,
                                zh,
                                d0,
                                κ,
                                TAIRs = air_temperatures,
                                VELs = wind_speeds,
                                RHs = humidities,
                                ZENRs = zenith_angles,
                                T0,
                                heights = heights_water_balance,
                                elevation,
                                pool,
                                θ_soil0_b,
                                PE = air_entry_water_potential,
                                KS = saturated_hydraulic_conductivity,
                                BB = Campbells_b_parameter,
                                BD = soil_bulk_density2,
                                DD = soil_mineral_density2,
                                depths,
                                moist_step,
                                L = root_density,
                                rw = root_resistance,
                                pc = stomatal_closure_potential,
                                rl = leaf_resistance,
                                sp = stomatal_stability_parameter,
                                r1 = root_radius,
                                lai,
                                im = moist_error,
                                moist_count,
                                niter_moist,
                                pctwet,
                                step,
                                maxpool,
                                M,
                                maximum_surface_temperature
                        )
                    end
                    if i < length(hours)
                        pools[step] = pool
                    end
                    longwave_out = get_longwave(;
                        elevation,
                        rh=humidities[step],
                        tair=air_temperatures[step],
                        tsurf=T0[1],
                        slep,
                        sle,
                        cloud=cloud_covers[step],
                        viewfactor,
                        shade,
                    )
                    Tsky = longwave_out.Tsky
                    if i < length(hours)
                        T_skys[step] = Tsky
                    end
                    # TODO: why use every second step what is this
                    sub = vcat(findall(isodd, 1:numnodes_b), numnodes_b)
                    θ_soil0_a = θ_soil0_b[sub]
                    λ_b, c_p_b, ρ_b = soil_properties!(soil_properties_buffers, T0, θ_soil0_a, nodes, soilprops, elevation, runmoist, false)
                    λ_bulk[step, :] = λ_b
                    c_p_bulk[step, :] = c_p_b
                    ρ_bulk[step, :] = ρ_b
                    if runmoist
                        if i < length(hours)
                            θ_soils[step, :] = infil_out.θ_soil[sub]
                            ψ_soils[step, :] = infil_out.ψ_soil[sub]
                            rh_soils[step, :] = infil_out.rh_soil[sub]
                        end
                    end
                end
            end
        end
    end
    # compute air temperature, wind speed and relative humidity profiles
    profile_out = map(1:length(air_temperatures)) do i
        # compute scalar profiles
        get_profile(;
            z0 = roughness_height,
            zh,
            d0,
            κ,
            reference_temperature=air_temperatures[i],
            reference_wind_speed=wind_speeds[i],
            relative_humidity=humidities[i],
            surface_temperature=u"°C"(T_soils[i][1]),  # top layer temp
            zenith_angle=zenith_angles[i],
            heights,
            maximum_surface_temperature,
        )
    end
    flip2vectors(x) = (; (k => getfield.(x, k) for k in keys(x[1]))...)
    profiles = flip2vectors(profile_out); # pull out each output as a vector
    air_temperature = reduce(hcat, profiles.air_temperatures)'
    wind_speed = reduce(hcat, profiles.wind_speeds)'
    relative_humidity = reduce(hcat, profiles.humidities)'

    return MicroResult(;
        air_temperature,
        wind_speed,
        relative_humidity,
        # TODO just use the same names in the code above 
        # all these name conversions are unnecesary
        cloud_cover = cloud_covers,
        global_solar,
        direct_solar,
        diffuse_solar,
        zenith_angle = zenith_angles,
        sky_temperature = T_skys,
        soil_temperature = reduce(vcat, transpose.(T_soils)),
        soil_moisture = θ_soils,
        soil_water_potential = ψ_soils,
        soil_humidity = rh_soils,
        soil_thermal_conductivity = λ_bulk,
        soil_specific_heat = c_p_bulk,
        soil_bulk_density = ρ_bulk,
        surface_water = pools,
        solrad=solrad_out,
        profile=profile_out,
    )
end
